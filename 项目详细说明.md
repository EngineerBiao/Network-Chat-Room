## 说明

参考资料：一口Linux的公众号文章：[从0实现基于Linux socket聊天室-多线程服务器模型-1 (qq.com)](https://mp.weixin.qq.com/s?__biz=MzUxMjEyNDgyNw==&mid=2247487494&idx=1&sn=24bb6d39889d3cd27982bb996a811470&chksm=f96862f2ce1febe4e329663a236bd6c569de8fe5c3e95f71316b7800b7c0b06d11a64cea4c86&scene=21#wechat_redirect)


### 项目简述

一个在Linux终端上运行的网络聊天室，主要功能有注册登录、公共聊天室和用户私聊室。主要涉及的技术有C语言、Socket编程、多线程编程、条件变量和锁、SQLite数据库、CMake

* **主要开发过程**

1. 使用Socket和多线程实现客户端与服务器的TCP连接和消息收发功能
2. 封装一个C/S统一的通信消息结构来确定服务器执行的函数
3. 使用CMake进行项目构建，使用Git进行版本管理
4. 使用SQLite3来操作数据库，实现用户信息的管理
5. 客户端使用多线程实现同时读取键盘输入和接收消息，并使用条件变量来协调线程之间的运行
6. 实现公聊和私聊功能等业务

* **与参考文章的不同之处**

1. 数据库存储的数据内容不同，例如将是否注册标志位换成了是否处于聊天状态标志位
2. 公聊和私聊的功能和实现方法不同，这两个功能都是自己设计和实现的。文中的功能较为粗糙，我的功能会更加完善一些
3. 还有各种细节，比如说构建工程的方法，文章直接用Makefile我是用Cmake。然后在客户端的主线程和接收数据的子线程之间用了锁加条件变量的方法来防止轮询，增加了程序的效率
4. 总结：其实主要就是参考了总体的思路，然后具体的实现都是自己思考自己写的



## 一、技术选型

### 1. Socket通信流程


![image-20240308002603150](https://biao-tu.oss-cn-shenzhen.aliyuncs.com/images/202403080026247.png)

### 2. 服务器模型

常用的网络服务器模型有下面3种

1. 多线程

每个网络请求由一个线程来处理，但线程内部还是会用到阻塞I/O

优点：实现简单

缺点：线程内部还是会被阻塞

2. 单线程I/O复用

将需要处理的socket读写事件都注册到epoll中

优点：实现简单、减少线程切换开销

缺点：只能用单核CPU，当客户端一多的时候就，因为全部处理都在一个线程所以性能会比较差

3. 多线程I/O复用

每个子进程监听服务，并且使用epoll机制来处理网络请求

优点：支持高并发。

缺点：编程难度较大

*  我的选择

由于对IO复用还不是很熟悉，所以目前选择了多线程模型。

主线程用于监听连接，每次连接成功后就把新的套接字传入子线程然后继续监听，注意要把新套接字的值赋值给堆区的内存并把堆区地址传入子线程。子线程拿到该套接字后就可以进行相关的操作了。

注：不能直接把accept返回的套接字的地址传给子线程，因为这可能导致在连接多个客户端时，栈中地址内容被改导致线程获取错误的值。具体原因看“一口Linux的第二篇文章”，这也符合多线程编程的一个要求，就是不把在主线程会变的值以地址的形式传到子线程中。



## 二、项目功能

1. 用户登录/注册

用户输入用户名和密码来登录或注册（用户名只包含数字且不能重复）

2. 列出在线用户及其聊天状态

列出在线用户的用户名名和他是否处于聊天状态

2. 公聊

用户选择公聊模式，会进入一个公共聊天室，在里面发送的消息会发送给所有进入了公共聊天室的用户。注：进入公共聊天室后需要先发一个消息才能被服务器识别为聊天状态，然后才能接收到其他用户的消息

4. 私聊

用户选择私聊功能，会先列出当前的在线用户



 

## 三、项目实现

### 1. 总实现架构

* 框架


服务端：主线程用来监听套接字连接，连接成功就创建一个子线程来专门与客户端进行通信，然后主线程继续监听

客户端：主线程用来处理登录、注册和菜单显示这些功能，然后当用户选择聊天后，唤醒子线程来处理聊天业务。

* 文件交互


![image-20231122170913281](https://biao-tu.oss-cn-shenzhen.aliyuncs.com/images/202311221709305.png)

client.c是客户端的用户程序，根据用户输入内容来执行相关的操作。server.c是服务端程序，它会调用data.c的函数来操作数据库。chat.h用来声明客户端与服务端之间的通信相关内容，例如消息的格式规定。

举一个注册的例子：客户端输入1选择注册功能并输入用户名和密码，然后客户端将注册消息发送给服务端，服务端接收到消息后会调用data.c的API来操作数据库从而实现客户端请求的注册功能。服务端处理完后发送处理结果给客户端，客户端上会打印出处理是否成功。



### 2. 消息通信和数据存储

* 消息通信

规定客户端和服务端之间的数据收发的格式，是一个Message结构体，成员有命令cmd、命令执行状态status、用户名name、数据data。1、命令的作用是让C/S执行对应的功能函数；2、执行状态的作用是服务器执行完命令后发送回一个消息，然后客户端根据该消息来判断操作是否成功，根据不同的情况打印不同的提示给用户；3、用户名和数据很好理解。

* 数据库存储

数据库每行记录的字段有：name(int)   password(text)   fd(int)   chat(int)

用户名和密码用来登录，fd用来判断用户是否在线，如果在线可以通过fd的值来与其进行通信。chat表示聊天状态，用来判断一个用户是否处于公聊或私聊状态



### 3. 注册和登录

* 客户端

注册和登录差不多，输入用户名和密码存在msg中发送给服务端

* 服务端

对于注册请求，先判断用户名是否注册过，没有就注册否则发送消息告知客户端用户名已被注册。对于登录请求，先后查询用户名是否被注册、密码是否正确、判断用户是否已上线。登录成功就把更新数据库的fd。



### 4. 公聊

* 客户端

在非聊天状态下（没进入公聊或私聊），客户端的子线程是阻塞在条件变量的等待函数中等待唤醒的。当进入聊天模式，主线程唤醒子线程让其开始实时接收聊天消息。主线程很简单就是不断scanf读取输入然后write到服务器，子线程需要控制终端光标，保证输入内容的那行和收到的消息之间不会冲突。

* 服务端

客户端选择公聊后更新客户端的聊天状态，之后判断发送的消息是否为”-1“，不为-1就调用data.c的广播函数，查找所有在线且处于聊天状态的用户，在回调函数中给他们发送消息



### 6. 私聊

服务端先发送在线用户列表给客户端，让用户选择要聊天的对象并发给服务端。服务端接收到选择的对象后，根据用户名找到对应的fd。当用户1和用户2都选择对方时，那么此时双方就能互相通信。



## 四、代办

1. 引入多路IO复用
2. 引入消息队列，处理客户端接收消息之后的存放问题